# Backend Implementation: Activity Last Updated Endpoint

## Overview
The frontend needs an endpoint to track the last updated timestamp for various activity types (requests, invoice_requests, invoices, etc.). This is used to show "new" badges on dashboard tabs when there are updates since the user last visited.

## Endpoint Specification

### GET /api/activity/last-updated

**Purpose**: Returns the last updated timestamp for each tracked activity type.

**Request**:
- Method: `GET`
- Headers: 
  - `Authorization: Bearer <token>` (optional - can be public or require authentication)
  - `Content-Type: application/json`
- URL: `/api/activity/last-updated`
- Query Parameters: None

**Response** (200 OK):
```json
{
  "success": true,
  "data": {
    "requests": "2024-01-15T10:30:00.000Z",
    "invoice_requests": "2024-01-15T11:45:00.000Z",
    "invoices": "2024-01-15T09:20:00.000Z",
    "delivery_assignments": "2024-01-15T12:00:00.000Z",
    "tickets": "2024-01-15T08:15:00.000Z",
    "collections": "2024-01-15T13:30:00.000Z",
    "jobs": "2024-01-15T10:00:00.000Z",
    "cash_flow": "2024-01-15T14:00:00.000Z",
    "reports": "2024-01-15T07:00:00.000Z"
  }
}
```

**Response Format**:
- Each key represents an activity type
- Each value is an ISO 8601 timestamp string (e.g., "2024-01-15T10:30:00.000Z")
- If an activity type has no records, return `null` or omit the key
- All timestamps should be in UTC

**Tracked Activity Types** (from frontend):
1. `requests` - General requests/bookings
2. `invoice_requests` - Invoice requests
3. `invoices` - Generated invoices
4. `delivery_assignments` - Delivery assignments
5. `tickets` - Support tickets
6. `collections` - Payment collections
7. `jobs` - Jobs/work orders
8. `cash_flow` - Cash flow entries
9. `reports` - Reports

---

## Implementation Logic

### Option 1: Query Each Collection (Recommended for accuracy)

Query each collection to find the most recent `updatedAt` or `createdAt` timestamp:

```javascript
// Express.js route handler example
router.get('/activity/last-updated', async (req, res) => {
  try {
    const lastUpdated = {};

    // 1. Requests/Bookings
    const latestRequest = await Booking.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.requests = latestRequest?.updatedAt?.toISOString() || null;

    // 2. Invoice Requests
    const latestInvoiceRequest = await InvoiceRequest.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.invoice_requests = latestInvoiceRequest?.updatedAt?.toISOString() || null;

    // 3. Invoices
    const latestInvoice = await Invoice.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.invoices = latestInvoice?.updatedAt?.toISOString() || null;

    // 4. Delivery Assignments
    const latestDelivery = await DeliveryAssignment.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.delivery_assignments = latestDelivery?.updatedAt?.toISOString() || null;

    // 5. Tickets
    const latestTicket = await Ticket.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.tickets = latestTicket?.updatedAt?.toISOString() || null;

    // 6. Collections
    const latestCollection = await Collection.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.collections = latestCollection?.updatedAt?.toISOString() || null;

    // 7. Jobs
    const latestJob = await Job.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.jobs = latestJob?.updatedAt?.toISOString() || null;

    // 8. Cash Flow
    const latestCashFlow = await CashFlow.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.cash_flow = latestCashFlow?.updatedAt?.toISOString() || null;

    // 9. Reports
    const latestReport = await Report.findOne()
      .sort({ updatedAt: -1 })
      .select('updatedAt')
      .lean();
    lastUpdated.reports = latestReport?.updatedAt?.toISOString() || null;

    return res.json({
      success: true,
      data: lastUpdated
    });
  } catch (error) {
    console.error('Error fetching activity last updated:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});
```

### Option 2: Use Aggregation Pipeline (More Efficient)

Use MongoDB aggregation to get max `updatedAt` for each collection:

```javascript
router.get('/activity/last-updated', async (req, res) => {
  try {
    const lastUpdated = {};

    // Parallel queries for better performance
    const [
      latestRequest,
      latestInvoiceRequest,
      latestInvoice,
      latestDelivery,
      latestTicket,
      latestCollection,
      latestJob,
      latestCashFlow,
      latestReport
    ] = await Promise.all([
      Booking.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ]),
      InvoiceRequest.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ]),
      Invoice.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ]),
      DeliveryAssignment.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ]),
      Ticket.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ]),
      Collection.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ]),
      Job.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ]),
      CashFlow.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ]),
      Report.aggregate([
        { $sort: { updatedAt: -1 } },
        { $limit: 1 },
        { $project: { updatedAt: 1 } }
      ])
    ]);

    lastUpdated.requests = latestRequest[0]?.updatedAt?.toISOString() || null;
    lastUpdated.invoice_requests = latestInvoiceRequest[0]?.updatedAt?.toISOString() || null;
    lastUpdated.invoices = latestInvoice[0]?.updatedAt?.toISOString() || null;
    lastUpdated.delivery_assignments = latestDelivery[0]?.updatedAt?.toISOString() || null;
    lastUpdated.tickets = latestTicket[0]?.updatedAt?.toISOString() || null;
    lastUpdated.collections = latestCollection[0]?.updatedAt?.toISOString() || null;
    lastUpdated.jobs = latestJob[0]?.updatedAt?.toISOString() || null;
    lastUpdated.cash_flow = latestCashFlow[0]?.updatedAt?.toISOString() || null;
    lastUpdated.reports = latestReport[0]?.updatedAt?.toISOString() || null;

    return res.json({
      success: true,
      data: lastUpdated
    });
  } catch (error) {
    console.error('Error fetching activity last updated:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});
```

### Option 3: Cached Approach (Best Performance)

Cache the results and update on document changes:

```javascript
// Cache with TTL (Time To Live)
let activityCache = null;
let cacheTimestamp = null;
const CACHE_TTL = 30000; // 30 seconds (matches frontend poll interval)

router.get('/activity/last-updated', async (req, res) => {
  try {
    const now = Date.now();
    
    // Return cached data if still valid
    if (activityCache && cacheTimestamp && (now - cacheTimestamp) < CACHE_TTL) {
      return res.json({
        success: true,
        data: activityCache
      });
    }

    // Fetch fresh data
    const lastUpdated = {};
    
    // ... (same queries as Option 1 or 2) ...
    
    // Update cache
    activityCache = lastUpdated;
    cacheTimestamp = now;

    return res.json({
      success: true,
      data: lastUpdated
    });
  } catch (error) {
    console.error('Error fetching activity last updated:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});
```

---

## Collection Name Mapping

Map the activity types to your actual collection/model names:

| Activity Type | Collection/Model Name | Notes |
|--------------|----------------------|-------|
| `requests` | `Booking` or `Request` | General bookings/requests |
| `invoice_requests` | `InvoiceRequest` | Invoice request documents |
| `invoices` | `Invoice` | Generated invoices |
| `delivery_assignments` | `DeliveryAssignment` or `Delivery` | Delivery assignments |
| `tickets` | `Ticket` or `SupportTicket` | Support tickets |
| `collections` | `Collection` or `Payment` | Payment collections |
| `jobs` | `Job` or `WorkOrder` | Jobs/work orders |
| `cash_flow` | `CashFlow` or `Transaction` | Cash flow entries |
| `reports` | `Report` | Generated reports |

**Important**: Update the model names in the code to match your actual schema.

---

## Timestamp Field

The endpoint should use the `updatedAt` field from each document. If your schema uses a different field name, adjust accordingly:

- `updatedAt` (Mongoose default)
- `updated_at`
- `modifiedAt`
- `lastModified`

If a document doesn't have `updatedAt`, fall back to `createdAt`:

```javascript
const timestamp = latestRequest?.updatedAt || latestRequest?.createdAt;
lastUpdated.requests = timestamp?.toISOString() || null;
```

---

## Error Handling

**500 Internal Server Error**:
```json
{
  "success": false,
  "error": "Internal server error"
}
```

**Handling Missing Collections**:
- If a collection doesn't exist or has no documents, return `null` for that key
- Don't throw errors for missing collections
- The frontend handles `null` values gracefully

---

## Performance Considerations

1. **Indexing**: Ensure `updatedAt` is indexed on all collections:
   ```javascript
   // In your Mongoose schemas
   schema.index({ updatedAt: -1 });
   ```

2. **Parallel Queries**: Use `Promise.all()` to query all collections in parallel

3. **Caching**: Consider caching results for 30 seconds (matches frontend poll interval)

4. **Lean Queries**: Use `.lean()` to return plain JavaScript objects (faster)

5. **Select Only Needed Fields**: Only select `updatedAt` field to reduce data transfer

---

## Frontend Integration

The frontend:
- Polls this endpoint every 30 seconds
- Compares returned timestamps with user's `lastSeen` timestamps (stored in localStorage)
- Shows "new" badges when `lastUpdated[key] > lastSeen[key]`
- Handles 404 errors gracefully (endpoint is optional)

**Frontend Code Reference**:
- Hook: `src/hooks/use-activity-badges.ts`
- API Client: `src/lib/api-client.ts` (method: `getActivityLastUpdated()`)
- Poll Interval: 30 seconds
- Tracked Keys: `['requests', 'invoice_requests', 'invoices', 'delivery_assignments', 'tickets', 'collections', 'jobs', 'cash_flow', 'reports']`

---

## Testing Checklist

- [ ] Endpoint returns 200 OK with correct structure
- [ ] All 9 activity types are included in response
- [ ] Timestamps are in ISO 8601 format (UTC)
- [ ] Handles empty collections (returns `null`)
- [ ] Handles missing collections gracefully
- [ ] Performance is acceptable (< 500ms response time)
- [ ] Works with authentication (if required)
- [ ] Caching works correctly (if implemented)
- [ ] Indexes are in place for `updatedAt` fields

---

## Example Response (All Collections Have Data)

```json
{
  "success": true,
  "data": {
    "requests": "2024-01-15T10:30:00.000Z",
    "invoice_requests": "2024-01-15T11:45:00.000Z",
    "invoices": "2024-01-15T09:20:00.000Z",
    "delivery_assignments": "2024-01-15T12:00:00.000Z",
    "tickets": "2024-01-15T08:15:00.000Z",
    "collections": "2024-01-15T13:30:00.000Z",
    "jobs": "2024-01-15T10:00:00.000Z",
    "cash_flow": "2024-01-15T14:00:00.000Z",
    "reports": "2024-01-15T07:00:00.000Z"
  }
}
```

## Example Response (Some Collections Empty)

```json
{
  "success": true,
  "data": {
    "requests": "2024-01-15T10:30:00.000Z",
    "invoice_requests": "2024-01-15T11:45:00.000Z",
    "invoices": "2024-01-15T09:20:00.000Z",
    "delivery_assignments": null,
    "tickets": null,
    "collections": "2024-01-15T13:30:00.000Z",
    "jobs": null,
    "cash_flow": "2024-01-15T14:00:00.000Z",
    "reports": null
  }
}
```

---

## Notes

- This endpoint is **optional** - the frontend handles 404 errors gracefully
- The endpoint should be fast (< 500ms) since it's polled every 30 seconds
- Consider implementing caching to reduce database load
- If some activity types don't exist in your system, return `null` for those keys
- All timestamps must be in UTC and ISO 8601 format
- The frontend compares timestamps client-side to determine if there are "new" items

---

## Route Registration

Make sure to register this route in your Express app:

```javascript
// In your routes file (e.g., routes/activity.js)
const express = require('express');
const router = express.Router();

router.get('/last-updated', async (req, res) => {
  // ... implementation ...
});

module.exports = router;

// In your main app file (e.g., app.js or server.js)
const activityRoutes = require('./routes/activity');
app.use('/api/activity', activityRoutes);
```

---

## Security Considerations

1. **Authentication**: Decide if this endpoint requires authentication
   - If public: No auth required
   - If private: Add authentication middleware

2. **Rate Limiting**: Consider rate limiting since it's polled frequently

3. **Data Exposure**: Only return timestamps, not sensitive data

---

## Quick Start Implementation

Minimal working example:

```javascript
// routes/activity.js
const express = require('express');
const router = express.Router();
const Booking = require('../models/Booking');
const InvoiceRequest = require('../models/InvoiceRequest');
const Invoice = require('../models/Invoice');

router.get('/last-updated', async (req, res) => {
  try {
    const [latestBooking, latestInvoiceRequest, latestInvoice] = await Promise.all([
      Booking.findOne().sort({ updatedAt: -1 }).select('updatedAt').lean(),
      InvoiceRequest.findOne().sort({ updatedAt: -1 }).select('updatedAt').lean(),
      Invoice.findOne().sort({ updatedAt: -1 }).select('updatedAt').lean()
    ]);

    return res.json({
      success: true,
      data: {
        requests: latestBooking?.updatedAt?.toISOString() || null,
        invoice_requests: latestInvoiceRequest?.updatedAt?.toISOString() || null,
        invoices: latestInvoice?.updatedAt?.toISOString() || null,
        delivery_assignments: null, // Add when collection exists
        tickets: null, // Add when collection exists
        collections: null, // Add when collection exists
        jobs: null, // Add when collection exists
        cash_flow: null, // Add when collection exists
        reports: null // Add when collection exists
      }
    });
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

module.exports = router;
```

