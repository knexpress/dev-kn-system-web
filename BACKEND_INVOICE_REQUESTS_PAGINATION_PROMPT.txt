BACKEND IMPLEMENTATION PROMPT: Invoice Requests Pagination and Filtering

## Overview
Implement server-side pagination and filtering for the invoice requests endpoint to improve performance and handle large datasets efficiently. The frontend will send pagination parameters and filters, and the backend should return only the requested page of data.

## Endpoint Specification

### GET /api/invoice-requests

**Query Parameters:**
- `page` (number, required): The page number to retrieve (default: 1)
- `limit` (number, required): Number of items per page (default: 25, max: 100)
- `status` (string, optional): Filter by status (DRAFT, SUBMITTED, IN_PROGRESS, VERIFIED, COMPLETED, CANCELLED)
- `search` (string, optional): Search query to filter by customer name, receiver name, AWB, invoice ID, or request ID

**Response Format:**
```json
{
  "success": true,
  "data": [
    {
      "_id": "request_id",
      "customer_name": "John Doe",
      "receiver_name": "Jane Smith",
      "awb": "AESY532AKLUUZEZ3V",
      "tracking_code": "AESY532AKLUUZEZ3V",
      "awb_number": "AESY532AKLUUZEZ3V",
      "origin_place": "Dubai",
      "destination_place": "Manila",
      "status": "VERIFIED",
      "invoice_id": "invoice_id_123",
      "invoice_number": "INV-2024-001",
      "verification": {
        "actual_weight": 10.5,
        "volumetric_weight": 12.0,
        "chargeable_weight": 12.0,
        "number_of_boxes": 2,
        "verified_at": "2024-01-01T00:00:00.000Z"
      },
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z"
    }
  ],
  "pagination": {
    "page": 1,
    "limit": 25,
    "total": 150,
    "pages": 6
  }
}
```

**Error Response:**
```json
{
  "success": false,
  "error": "Error message"
}
```

## Implementation Requirements

1. **Pagination Logic:**
   - Default `page` = 1, `limit` = 25
   - Maximum `limit` = 100 (to prevent performance issues)
   - Calculate `skip` = (page - 1) * limit
   - Use MongoDB `skip()` and `limit()` methods
   - Calculate total count before pagination for accurate pagination info

2. **Status Filtering:**
   - If `status` parameter is provided and not 'all', filter by exact status match
   - Case-insensitive matching
   - Support status values: DRAFT, SUBMITTED, IN_PROGRESS, VERIFIED, COMPLETED, CANCELLED

3. **Search Functionality:**
   - If `search` parameter is provided, search across multiple fields:
     - `customer_name` (case-insensitive partial match)
     - `receiver_name` (case-insensitive partial match)
     - `awb` (case-insensitive partial match)
     - `tracking_code` (case-insensitive partial match)
     - `awb_number` (case-insensitive partial match)
     - `invoice_id` (case-insensitive partial match)
     - `invoice_number` (case-insensitive partial match)
     - `_id` (partial match on string representation)
   - Use MongoDB `$or` operator to search across all fields
   - Use case-insensitive regex for partial matching

4. **Query Building:**
   - Build query object based on filters
   - Apply search filter first (if provided)
   - Apply status filter (if provided)
   - Count total matching documents
   - Apply pagination (skip and limit)
   - Sort by `createdAt` descending (newest first) or `updatedAt` descending

5. **Performance Considerations:**
   - Add indexes on frequently queried fields:
     - `status` (for status filtering)
     - `customer_name` (for search)
     - `receiver_name` (for search)
     - `awb`, `tracking_code`, `awb_number` (for search)
     - `invoice_id`, `invoice_number` (for search)
     - `createdAt` (for sorting)
   - Use MongoDB text indexes if available for better search performance
   - Consider compound indexes for common filter combinations

6. **Response Structure:**
   - Always return pagination metadata even if no results
   - Calculate `pages` = Math.ceil(total / limit)
   - Ensure `data` is always an array (empty array if no results)

## Example Implementation (Node.js/Express with Mongoose)

```javascript
// Route handler
router.get('/invoice-requests', authenticate, async (req, res) => {
  try {
    // Parse query parameters
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 25, 100); // Max 100
    const status = req.query.status;
    const search = req.query.search;
    
    // Build query object
    const query = {};
    
    // Status filter
    if (status && status !== 'all') {
      query.status = { $regex: new RegExp(`^${status}$`, 'i') };
    }
    
    // Search filter
    if (search && search.trim()) {
      const searchRegex = new RegExp(search.trim(), 'i');
      query.$or = [
        { customer_name: searchRegex },
        { receiver_name: searchRegex },
        { awb: searchRegex },
        { tracking_code: searchRegex },
        { awb_number: searchRegex },
        { invoice_id: searchRegex },
        { invoice_number: searchRegex },
        { _id: { $regex: search.trim() } }
      ];
    }
    
    // Calculate pagination
    const skip = (page - 1) * limit;
    
    // Get total count (before pagination)
    const total = await InvoiceRequest.countDocuments(query);
    
    // Fetch paginated data
    const invoiceRequests = await InvoiceRequest.find(query)
      .sort({ createdAt: -1 }) // Newest first
      .skip(skip)
      .limit(limit)
      .lean(); // Use lean() for better performance
    
    // Calculate total pages
    const pages = Math.ceil(total / limit);
    
    return res.json({
      success: true,
      data: invoiceRequests,
      pagination: {
        page,
        limit,
        total,
        pages
      }
    });
  } catch (error) {
    console.error('Error fetching invoice requests:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to fetch invoice requests'
    });
  }
});
```

## Database Indexes

Add the following indexes to improve query performance:

```javascript
// MongoDB indexes
db.invoice_requests.createIndex({ status: 1 });
db.invoice_requests.createIndex({ customer_name: 1 });
db.invoice_requests.createIndex({ receiver_name: 1 });
db.invoice_requests.createIndex({ awb: 1 });
db.invoice_requests.createIndex({ tracking_code: 1 });
db.invoice_requests.createIndex({ awb_number: 1 });
db.invoice_requests.createIndex({ invoice_id: 1 });
db.invoice_requests.createIndex({ invoice_number: 1 });
db.invoice_requests.createIndex({ createdAt: -1 });

// Compound indexes for common queries
db.invoice_requests.createIndex({ status: 1, createdAt: -1 });
db.invoice_requests.createIndex({ customer_name: 1, status: 1 });

// Text index for full-text search (optional, for better search performance)
db.invoice_requests.createIndex({ 
  customer_name: "text", 
  receiver_name: "text",
  awb: "text",
  tracking_code: "text",
  awb_number: "text",
  invoice_number: "text"
});
```

## Testing

Test cases to verify:
1. Pagination with default parameters (page=1, limit=25)
2. Pagination with custom page and limit
3. Status filtering (each status value)
4. Search functionality (each searchable field)
5. Combined status and search filters
6. Edge cases:
   - Page number beyond total pages (should return empty array)
   - Invalid page number (should default to 1)
   - Invalid limit (should cap at 100)
   - Empty search query (should be ignored)
   - No results matching filters (should return empty array with correct pagination)
7. Performance test with large dataset (1000+ records)
8. Verify pagination metadata is always accurate

## Performance Goals

- Response time should be < 500ms for typical queries
- Should handle datasets with 10,000+ records efficiently
- Database queries should use indexes (check with explain())
- Memory usage should be reasonable (don't load all records into memory)

## Notes

- The frontend expects the response to match the format exactly
- Pagination metadata is required for proper frontend pagination controls
- Search should be fast enough for real-time filtering
- Consider caching frequently accessed pages if performance becomes an issue
- The endpoint should maintain backward compatibility if possible (handle missing pagination params)

