================================================================================
BACKEND IMPLEMENTATION PROMPT: Booking Form Data Analysis and Client Sync
================================================================================

OVERVIEW
--------
When a booking is created or saved in the system, automatically analyze the 
customer/sender names and sync them with the clients collection. If a customer 
or sender name already exists in the bookings collection, do NOT add them as a 
new client. Only add new clients if the name doesn't exist in any booking.

================================================================================
REQUIREMENT 1: BOOKING CREATION/UPDATE ENDPOINT
================================================================================

ENDPOINT: POST /api/bookings
ENDPOINT: PUT /api/bookings/:id

When a booking is created or updated, the backend should:

1. Save the booking data to the bookings collection as normal
2. After successfully saving the booking, trigger the client sync process
3. Analyze customer and sender names from the booking
4. Check if these names already exist in the bookings collection
5. Only add to clients collection if name doesn't exist

================================================================================
REQUIREMENT 2: CLIENT SYNC LOGIC
================================================================================

STEP 1: EXTRACT NAMES FROM BOOKING
-----------------------------------
Extract customer/sender names from the booking object. Check these fields:

Customer Name Fields (in priority order):
- booking.customer_name
- booking.name
- booking.sender.fullName
- booking.sender.name
- booking.sender.firstName + booking.sender.lastName

Sender Name Fields (if different from customer):
- booking.sender.fullName
- booking.sender.name
- booking.sender.firstName + booking.sender.lastName

Receiver Name Fields (optional - for future use):
- booking.receiver_name
- booking.receiver.fullName
- booking.receiver.name

STEP 2: NORMALIZE NAMES
------------------------
Before checking for duplicates, normalize the names:
- Convert to lowercase
- Trim whitespace
- Remove extra spaces
- Remove special characters (optional - be careful with names like O'Brien)

Example normalization:
"John  Doe  " -> "john doe"
"Mary-Jane Smith" -> "mary-jane smith" (or "maryjane smith" based on preference)

STEP 3: CHECK FOR EXISTING NAMES IN BOOKINGS COLLECTION
--------------------------------------------------------
Query the bookings collection to check if the normalized name already exists:

For Customer Name:
- Search in: customer_name, name, sender.fullName, sender.name fields
- Use case-insensitive matching
- Use normalized name comparison

For Sender Name (if different from customer):
- Search in: sender.fullName, sender.name fields
- Use case-insensitive matching
- Use normalized name comparison

MongoDB Query Example:
```javascript
const normalizedName = customerName.toLowerCase().trim().replace(/\s+/g, ' ');

const existingBooking = await Booking.findOne({
  $or: [
    { customer_name: { $regex: new RegExp(`^${normalizedName}$`, 'i') } },
    { name: { $regex: new RegExp(`^${normalizedName}$`, 'i') } },
    { 'sender.fullName': { $regex: new RegExp(`^${normalizedName}$`, 'i') } },
    { 'sender.name': { $regex: new RegExp(`^${normalizedName}$`, 'i') } }
  ]
});
```

STEP 4: ADD TO CLIENTS COLLECTION (IF NOT EXISTS)
---------------------------------------------------
If the name does NOT exist in any booking:

1. Check if client already exists in clients collection (by name, email, or phone)
2. If client doesn't exist in clients collection, create a new client record
3. Extract additional information from booking:
   - Name: customer_name or sender.name
   - Email: customer_email, email, sender.emailAddress, sender.email
   - Phone: customer_phone, phone, sender.contactNo, sender.phone, sender.phoneNumber
   - Address: sender_address, sender.completeAddress, sender.address, origin_place
   - Contact Person: customer_name or sender.name

Client Document Structure:
```javascript
{
  company_name: customerName, // or sender name
  name: customerName, // same as company_name for individual clients
  contact_name: customerName, // primary contact
  email: extractedEmail || null,
  phone: extractedPhone || null,
  address: extractedAddress || null,
  emailAddress: extractedEmail || null,
  phoneNumber: extractedPhone || null,
  completeAddress: extractedAddress || null,
  created_at: new Date(),
  updated_at: new Date(),
  source: 'booking_auto_sync' // to track that this was auto-created from booking
}
```

STEP 5: HANDLE DUPLICATES IN CLIENTS COLLECTION
------------------------------------------------
Before adding to clients collection, check for duplicates by:
- Name (normalized, case-insensitive)
- Email (if provided)
- Phone (if provided)

If a client with the same name/email/phone already exists, DO NOT create a duplicate.
Instead, you can optionally update the existing client with new information if needed.

================================================================================
REQUIREMENT 3: IMPLEMENTATION DETAILS
================================================================================

FUNCTION: syncClientFromBooking(bookingData)
--------------------------------------------
This function should be called after a booking is successfully saved.

Pseudocode:
```javascript
async function syncClientFromBooking(bookingData) {
  try {
    // Step 1: Extract customer name
    const customerName = extractCustomerName(bookingData);
    if (!customerName) return; // No name to process
    
    // Step 2: Normalize name
    const normalizedName = normalizeName(customerName);
    
    // Step 3: Check if name exists in bookings collection
    const nameExists = await checkNameInBookings(normalizedName);
    
    // Step 4: If name doesn't exist, add to clients
    if (!nameExists) {
      // Check if client already exists in clients collection
      const existingClient = await checkClientExists(normalizedName, bookingData);
      
      if (!existingClient) {
        // Create new client
        const clientData = extractClientData(bookingData);
        await createClient(clientData);
      }
    }
    
    // Optional: Also check sender name if different from customer
    const senderName = extractSenderName(bookingData);
    if (senderName && senderName !== customerName) {
      const normalizedSenderName = normalizeName(senderName);
      const senderNameExists = await checkNameInBookings(normalizedSenderName);
      
      if (!senderNameExists) {
        const existingSenderClient = await checkClientExists(normalizedSenderName, bookingData);
        if (!existingSenderClient) {
          const senderClientData = extractClientData(bookingData, 'sender');
          await createClient(senderClientData);
        }
      }
    }
  } catch (error) {
    console.error('Error syncing client from booking:', error);
    // Don't fail the booking creation if client sync fails
    // Log error but continue
  }
}
```

HELPER FUNCTIONS:
-----------------
1. extractCustomerName(booking) - Extract customer name from various fields
2. extractSenderName(booking) - Extract sender name if different
3. normalizeName(name) - Normalize name for comparison
4. checkNameInBookings(normalizedName) - Check if name exists in bookings
5. checkClientExists(name, bookingData) - Check if client exists in clients collection
6. extractClientData(booking, type) - Extract client data from booking
7. createClient(clientData) - Create new client in clients collection

================================================================================
REQUIREMENT 4: API ENDPOINT INTEGRATION
================================================================================

INTEGRATE INTO EXISTING ENDPOINTS:
----------------------------------
1. POST /api/bookings
   - After booking is saved successfully
   - Call syncClientFromBooking(bookingData)
   - Return booking response as normal

2. PUT /api/bookings/:id
   - After booking is updated successfully
   - Call syncClientFromBooking(updatedBookingData)
   - Return updated booking response as normal

3. BATCH OPERATIONS (if applicable)
   - If processing multiple bookings at once
   - Process each booking individually through syncClientFromBooking
   - Handle errors per booking without failing the entire batch

================================================================================
REQUIREMENT 5: ERROR HANDLING
================================================================================

- Client sync should NOT fail the booking creation/update
- If client sync fails, log the error but return success for booking operation
- Use try-catch blocks around client sync logic
- Consider using a queue/background job for client sync if performance is a concern

Example:
```javascript
// In booking creation endpoint
try {
  const booking = await Booking.create(bookingData);
  
  // Sync client in background (don't wait for it)
  syncClientFromBooking(booking).catch(err => {
    console.error('Background client sync failed:', err);
  });
  
  return res.json({ success: true, data: booking });
} catch (error) {
  return res.status(500).json({ success: false, error: error.message });
}
```

================================================================================
REQUIREMENT 6: DATA VALIDATION
================================================================================

Before adding to clients collection, validate:
- Name is not empty
- Name is at least 2 characters
- Email format is valid (if provided)
- Phone format is valid (if provided)

Skip client creation if:
- Name is empty or too short
- All contact information (email, phone, address) is missing (optional - you may still want to create with just name)

================================================================================
REQUIREMENT 7: TESTING CHECKLIST
================================================================================

Test Cases:
-----------
1. ✅ New booking with new customer name → Should create new client
2. ✅ New booking with existing customer name in bookings → Should NOT create client
3. ✅ New booking with customer name that exists in clients → Should NOT create duplicate
4. ✅ Booking update with new customer name → Should create new client if name doesn't exist
5. ✅ Booking with sender name different from customer → Should check both names
6. ✅ Booking with missing name → Should skip client creation
7. ✅ Booking with normalized name matching existing booking → Should NOT create duplicate
8. ✅ Case-insensitive name matching → "John Doe" should match "john doe"
9. ✅ Name with extra spaces → "John  Doe" should match "John Doe"
10. ✅ Client sync failure should not fail booking creation

================================================================================
REQUIREMENT 8: PERFORMANCE CONSIDERATIONS
================================================================================

- Use database indexes on name fields in bookings collection for faster lookups
- Consider caching normalized names if performance is an issue
- Use background jobs/queues for client sync if processing many bookings
- Limit the number of database queries (use $or queries instead of multiple queries)

INDEXES TO CREATE:
------------------
```javascript
// In bookings collection
db.bookings.createIndex({ "customer_name": 1 });
db.bookings.createIndex({ "name": 1 });
db.bookings.createIndex({ "sender.fullName": 1 });
db.bookings.createIndex({ "sender.name": 1 });

// In clients collection
db.clients.createIndex({ "company_name": 1 });
db.clients.createIndex({ "name": 1 });
db.clients.createIndex({ "email": 1 });
db.clients.createIndex({ "phone": 1 });
```

================================================================================
REQUIREMENT 9: LOGGING AND MONITORING
================================================================================

Log the following events:
- Client created from booking sync
- Client skipped (name already exists in bookings)
- Client skipped (already exists in clients collection)
- Client sync errors

Example log format:
```
[CLIENT_SYNC] Created new client: John Doe (from booking: booking_id)
[CLIENT_SYNC] Skipped client creation: Jane Smith (exists in bookings)
[CLIENT_SYNC] Error syncing client: Error message
```

================================================================================
REQUIREMENT 10: CONFIGURATION
================================================================================

Make the following configurable (via environment variables or config):
- Enable/disable auto client sync
- Minimum name length for client creation
- Whether to create clients with only name (no contact info)
- Whether to update existing clients with new information

Example config:
```javascript
const CLIENT_SYNC_CONFIG = {
  enabled: process.env.AUTO_CLIENT_SYNC === 'true',
  minNameLength: parseInt(process.env.MIN_CLIENT_NAME_LENGTH || '2'),
  requireContactInfo: process.env.REQUIRE_CLIENT_CONTACT_INFO === 'true',
  updateExisting: process.env.UPDATE_EXISTING_CLIENTS === 'true'
};
```

================================================================================
EXAMPLE IMPLEMENTATION (Node.js/Express/MongoDB)
================================================================================

```javascript
// utils/client-sync.js

const Booking = require('../models/Booking');
const Client = require('../models/Client');

function extractCustomerName(booking) {
  return booking.customer_name || 
         booking.name || 
         booking.sender?.fullName || 
         booking.sender?.name ||
         (booking.sender?.firstName && booking.sender?.lastName 
           ? `${booking.sender.firstName} ${booking.sender.lastName}` 
           : null);
}

function normalizeName(name) {
  if (!name) return '';
  return name.toLowerCase().trim().replace(/\s+/g, ' ');
}

async function checkNameInBookings(normalizedName) {
  const regex = new RegExp(`^${normalizedName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i');
  
  const existingBooking = await Booking.findOne({
    $or: [
      { customer_name: { $regex: regex } },
      { name: { $regex: regex } },
      { 'sender.fullName': { $regex: regex } },
      { 'sender.name': { $regex: regex } }
    ]
  });
  
  return !!existingBooking;
}

async function checkClientExists(normalizedName, bookingData) {
  const regex = new RegExp(`^${normalizedName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i');
  
  const email = bookingData.customer_email || bookingData.email || bookingData.sender?.emailAddress;
  const phone = bookingData.customer_phone || bookingData.phone || bookingData.sender?.contactNo;
  
  const query = {
    $or: [
      { company_name: { $regex: regex } },
      { name: { $regex: regex } }
    ]
  };
  
  if (email) {
    query.$or.push({ email: email.toLowerCase() });
  }
  if (phone) {
    query.$or.push({ phone: phone });
  }
  
  const existingClient = await Client.findOne(query);
  return existingClient;
}

function extractClientData(booking, type = 'customer') {
  const source = type === 'customer' ? booking : booking.sender;
  
  return {
    company_name: extractCustomerName(booking),
    name: extractCustomerName(booking),
    contact_name: extractCustomerName(booking),
    email: booking.customer_email || booking.email || source?.emailAddress || source?.email || null,
    phone: booking.customer_phone || booking.phone || source?.contactNo || source?.phone || source?.phoneNumber || null,
    address: booking.sender_address || source?.completeAddress || source?.address || booking.origin_place || null,
    emailAddress: booking.customer_email || booking.email || source?.emailAddress || source?.email || null,
    phoneNumber: booking.customer_phone || booking.phone || source?.contactNo || source?.phone || source?.phoneNumber || null,
    completeAddress: booking.sender_address || source?.completeAddress || source?.address || booking.origin_place || null,
    created_at: new Date(),
    updated_at: new Date(),
    source: 'booking_auto_sync'
  };
}

async function syncClientFromBooking(bookingData) {
  if (!CLIENT_SYNC_CONFIG.enabled) {
    return;
  }
  
  try {
    const customerName = extractCustomerName(bookingData);
    if (!customerName || customerName.length < CLIENT_SYNC_CONFIG.minNameLength) {
      console.log('[CLIENT_SYNC] Skipped: Invalid customer name');
      return;
    }
    
    const normalizedName = normalizeName(customerName);
    const nameExists = await checkNameInBookings(normalizedName);
    
    if (!nameExists) {
      const existingClient = await checkClientExists(normalizedName, bookingData);
      
      if (!existingClient) {
        const clientData = extractClientData(bookingData);
        
        // Validate contact info if required
        if (CLIENT_SYNC_CONFIG.requireContactInfo) {
          if (!clientData.email && !clientData.phone) {
            console.log('[CLIENT_SYNC] Skipped: No contact information');
            return;
          }
        }
        
        const newClient = await Client.create(clientData);
        console.log(`[CLIENT_SYNC] Created new client: ${customerName} (ID: ${newClient._id})`);
      } else {
        console.log(`[CLIENT_SYNC] Skipped: Client already exists: ${customerName}`);
        
        // Optionally update existing client
        if (CLIENT_SYNC_CONFIG.updateExisting) {
          // Update logic here
        }
      }
    } else {
      console.log(`[CLIENT_SYNC] Skipped: Name exists in bookings: ${customerName}`);
    }
    
    // Handle sender name if different
    const senderName = extractSenderName(bookingData);
    if (senderName && senderName !== customerName) {
      const normalizedSenderName = normalizeName(senderName);
      const senderNameExists = await checkNameInBookings(normalizedSenderName);
      
      if (!senderNameExists) {
        const existingSenderClient = await checkClientExists(normalizedSenderName, bookingData);
        if (!existingSenderClient) {
          const senderClientData = extractClientData(bookingData, 'sender');
          await Client.create(senderClientData);
          console.log(`[CLIENT_SYNC] Created new sender client: ${senderName}`);
        }
      }
    }
  } catch (error) {
    console.error('[CLIENT_SYNC] Error:', error);
    // Don't throw - let booking creation succeed even if sync fails
  }
}

module.exports = { syncClientFromBooking };

// In booking routes
const { syncClientFromBooking } = require('../utils/client-sync');

router.post('/bookings', async (req, res) => {
  try {
    const booking = await Booking.create(req.body);
    
    // Sync client in background
    syncClientFromBooking(booking).catch(err => {
      console.error('Background client sync failed:', err);
    });
    
    res.json({ success: true, data: booking });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

================================================================================
END OF PROMPT
================================================================================

