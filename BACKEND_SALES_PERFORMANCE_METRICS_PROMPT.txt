================================================================================
BACKEND IMPLEMENTATION PROMPT: Sales Department Performance Metrics Endpoint
================================================================================

OVERVIEW
--------
Create an API endpoint that calculates and returns performance metrics for the 
Sales department. This endpoint will be called by the frontend dashboard to 
display key performance indicators (KPIs) for sales team members.

================================================================================
REQUIREMENT 1: ENDPOINT SPECIFICATION
================================================================================

ENDPOINT: GET /api/performance/department/Sales

PURPOSE:
--------
Calculate and return real-time performance metrics for the Sales department 
including revenue, leads, conversion rate, and client satisfaction.

AUTHENTICATION:
---------------
- Require authentication (JWT token or session)
- Verify user has access to Sales department data
- Optional: Only allow Sales department members to access

================================================================================
REQUIREMENT 2: METRICS TO CALCULATE
================================================================================

The endpoint must calculate and return the following 4 metrics:

1. MONTHLY REVENUE
   - Field: revenue
   - Type: Number (decimal/float)
   - Unit: AED
   - Description: Total revenue generated by Sales department this month
   - Calculation: Sum of all invoice amounts where:
     * Invoice was created this month (current month)
     * Invoice is related to requests created by Sales department employees
     * OR: Sum of all invoice amounts from invoice requests created by Sales employees
   - Trend: Compare current month vs previous month
   - Trend Percentage: ((current - previous) / previous) * 100

2. NEW LEADS
   - Field: newLeads
   - Type: Number (integer)
   - Unit: Count
   - Description: Number of new leads/customers generated this month
   - Calculation: Count of:
     * New clients created this month
     * OR: New bookings created this month
     * OR: New invoice requests created this month by Sales employees
   - Trend: Compare current month vs previous month
   - Trend Percentage: ((current - previous) / previous) * 100

3. CONVERSION RATE
   - Field: conversionRate
   - Type: Number (decimal/float)
   - Unit: Percentage (%)
   - Description: Lead to customer conversion rate
   - Calculation: (Converted Leads / Total Leads) * 100
     * Converted Leads: Leads that resulted in completed invoices/bookings
     * Total Leads: All leads generated in the period
   - Period: Can be current month or last 30 days
   - Trend: Compare current period vs previous period
   - Trend Percentage: ((current - previous) / previous) * 100

4. CLIENT SATISFACTION
   - Field: clientSatisfaction
   - Type: Number (decimal/float)
   - Unit: Percentage (%)
   - Description: Average client satisfaction score
   - Calculation: Average of satisfaction scores (if available)
   - Fallback: Can be calculated from:
     * Low complaint rate
     * High repeat customer rate
     * On-time delivery rate for Sales-created requests
   - Default: If no satisfaction data, use a calculated score based on:
     * Repeat customers / Total customers * 100
     * Or: (1 - (complaints / total_requests)) * 100
   - Trend: Compare current period vs previous period
   - Trend Percentage: ((current - previous) / previous) * 100

================================================================================
REQUIREMENT 3: RESPONSE FORMAT
================================================================================

SUCCESS RESPONSE (200 OK):
--------------------------
{
  "success": true,
  "data": {
    "revenue": 50000.00,
    "revenueTrend": "up",
    "revenueTrendPercentage": 12.5,
    "newLeads": 45,
    "leadsTrend": "up",
    "leadsTrendPercentage": 8.3,
    "conversionRate": 65.5,
    "conversionTrend": "neutral",
    "conversionTrendPercentage": 0.0,
    "clientSatisfaction": 88.2,
    "satisfactionTrend": "up",
    "satisfactionTrendPercentage": 5.2
  }
}

ERROR RESPONSE (500 Internal Server Error):
-------------------------------------------
{
  "success": false,
  "error": "Failed to calculate performance metrics"
}

ERROR RESPONSE (401 Unauthorized):
----------------------------------
{
  "success": false,
  "error": "Unauthorized access"
}

================================================================================
REQUIREMENT 4: TREND CALCULATION
================================================================================

For each metric, calculate trend by comparing:
- Current Period: Current month (or last 30 days)
- Previous Period: Previous month (or previous 30 days)

TREND VALUES:
-------------
- "up": Current value > Previous value
- "down": Current value < Previous value
- "neutral": Current value = Previous value (or difference < 1%)

TREND PERCENTAGE:
-----------------
Calculate as: ((current - previous) / previous) * 100
- Round to 1 decimal place
- Handle division by zero (if previous is 0, set trend to "neutral" and percentage to 0)

================================================================================
REQUIREMENT 5: DATA SOURCES
================================================================================

The metrics should be calculated from the following database collections:

1. INVOICES COLLECTION
   - Field: total_amount or amount
   - Field: created_at or createdAt
   - Field: created_by or created_by_employee_id
   - Field: status
   - Use: Calculate revenue from invoices created this month

2. INVOICE REQUESTS COLLECTION
   - Field: created_at or createdAt
   - Field: created_by_employee_id
   - Field: status
   - Use: Count new leads (new invoice requests)
   - Use: Track conversion (requests that became invoices)

3. CLIENTS COLLECTION
   - Field: created_at or createdAt
   - Field: created_by or created_by_employee_id
   - Use: Count new clients/leads

4. BOOKINGS COLLECTION
   - Field: created_at or createdAt
   - Field: created_by_employee_id
   - Use: Count new bookings as leads

5. COMPLAINTS/TICKETS COLLECTION (if available)
   - Use: Calculate satisfaction score

================================================================================
REQUIREMENT 6: IMPLEMENTATION DETAILS
================================================================================

STEP 1: IDENTIFY SALES EMPLOYEES
---------------------------------
Query employees collection to get all employees in Sales department:
- Filter: department.name === 'Sales' OR department === 'Sales'
- Get: employee_id or _id for all Sales employees

STEP 2: CALCULATE MONTHLY REVENUE
----------------------------------
```javascript
// Get current month date range
const currentMonthStart = new Date(currentYear, currentMonth, 1);
const currentMonthEnd = new Date(currentYear, currentMonth + 1, 0, 23, 59, 59);

// Get previous month date range
const previousMonthStart = new Date(currentYear, currentMonth - 1, 1);
const previousMonthEnd = new Date(currentYear, currentMonth, 0, 23, 59, 59);

// Query invoices created by Sales employees in current month
const currentMonthRevenue = await Invoice.aggregate([
  {
    $match: {
      created_at: { $gte: currentMonthStart, $lte: currentMonthEnd },
      created_by: { $in: salesEmployeeIds },
      status: { $ne: 'CANCELLED' }
    }
  },
  {
    $group: {
      _id: null,
      total: { $sum: '$total_amount' }
    }
  }
]);

// Query invoices created by Sales employees in previous month
const previousMonthRevenue = await Invoice.aggregate([
  {
    $match: {
      created_at: { $gte: previousMonthStart, $lte: previousMonthEnd },
      created_by: { $in: salesEmployeeIds },
      status: { $ne: 'CANCELLED' }
    }
  },
  {
    $group: {
      _id: null,
      total: { $sum: '$total_amount' }
    }
  }
]);

// Calculate trend
const revenue = currentMonthRevenue[0]?.total || 0;
const previousRevenue = previousMonthRevenue[0]?.total || 0;
const revenueTrend = calculateTrend(revenue, previousRevenue);
const revenueTrendPercentage = calculateTrendPercentage(revenue, previousRevenue);
```

STEP 3: CALCULATE NEW LEADS
----------------------------
```javascript
// Count new invoice requests created by Sales employees
const currentMonthLeads = await InvoiceRequest.countDocuments({
  created_at: { $gte: currentMonthStart, $lte: currentMonthEnd },
  created_by_employee_id: { $in: salesEmployeeIds }
});

const previousMonthLeads = await InvoiceRequest.countDocuments({
  created_at: { $gte: previousMonthStart, $lte: previousMonthEnd },
  created_by_employee_id: { $in: salesEmployeeIds }
});

// Or count new clients created
// const currentMonthLeads = await Client.countDocuments({
//   created_at: { $gte: currentMonthStart, $lte: currentMonthEnd },
//   created_by: { $in: salesEmployeeIds }
// });

const newLeads = currentMonthLeads;
const leadsTrend = calculateTrend(currentMonthLeads, previousMonthLeads);
const leadsTrendPercentage = calculateTrendPercentage(currentMonthLeads, previousMonthLeads);
```

STEP 4: CALCULATE CONVERSION RATE
----------------------------------
```javascript
// Get total leads (invoice requests) in current period
const totalLeads = await InvoiceRequest.countDocuments({
  created_at: { $gte: currentMonthStart, $lte: currentMonthEnd },
  created_by_employee_id: { $in: salesEmployeeIds }
});

// Get converted leads (invoice requests that became invoices)
const convertedLeads = await InvoiceRequest.countDocuments({
  created_at: { $gte: currentMonthStart, $lte: currentMonthEnd },
  created_by_employee_id: { $in: salesEmployeeIds },
  status: 'COMPLETED' // or has related invoice
});

// Calculate conversion rate
const conversionRate = totalLeads > 0 ? (convertedLeads / totalLeads) * 100 : 0;

// Calculate previous period conversion rate
const previousTotalLeads = await InvoiceRequest.countDocuments({
  created_at: { $gte: previousMonthStart, $lte: previousMonthEnd },
  created_by_employee_id: { $in: salesEmployeeIds }
});

const previousConvertedLeads = await InvoiceRequest.countDocuments({
  created_at: { $gte: previousMonthStart, $lte: previousMonthEnd },
  created_by_employee_id: { $in: salesEmployeeIds },
  status: 'COMPLETED'
});

const previousConversionRate = previousTotalLeads > 0 
  ? (previousConvertedLeads / previousTotalLeads) * 100 
  : 0;

const conversionTrend = calculateTrend(conversionRate, previousConversionRate);
const conversionTrendPercentage = calculateTrendPercentage(conversionRate, previousConversionRate);
```

STEP 5: CALCULATE CLIENT SATISFACTION
-------------------------------------
```javascript
// Option 1: If you have satisfaction scores in database
const satisfactionScores = await Client.aggregate([
  {
    $match: {
      created_by: { $in: salesEmployeeIds },
      satisfaction_score: { $exists: true, $ne: null }
    }
  },
  {
    $group: {
      _id: null,
      avgSatisfaction: { $avg: '$satisfaction_score' }
    }
  }
]);

// Option 2: Calculate from repeat customers
const totalClients = await Client.countDocuments({
  created_by: { $in: salesEmployeeIds }
});

const repeatClients = await Client.countDocuments({
  created_by: { $in: salesEmployeeIds },
  booking_count: { $gt: 1 } // or invoice_count > 1
});

const clientSatisfaction = totalClients > 0 
  ? (repeatClients / totalClients) * 100 
  : 85; // Default score if no data

// Option 3: Calculate from low complaint rate
const totalRequests = await InvoiceRequest.countDocuments({
  created_by_employee_id: { $in: salesEmployeeIds }
});

const complaints = await Ticket.countDocuments({
  type: 'complaint',
  related_request: { $in: requestIds } // requests created by Sales
});

const clientSatisfaction = totalRequests > 0
  ? (1 - (complaints / totalRequests)) * 100
  : 85;

// Calculate trend (compare current vs previous period)
const previousSatisfaction = /* calculate for previous period */;
const satisfactionTrend = calculateTrend(clientSatisfaction, previousSatisfaction);
const satisfactionTrendPercentage = calculateTrendPercentage(clientSatisfaction, previousSatisfaction);
```

HELPER FUNCTIONS:
-----------------
```javascript
function calculateTrend(current, previous) {
  if (previous === 0 || previous === null) {
    return current > 0 ? 'up' : 'neutral';
  }
  const diff = current - previous;
  if (Math.abs(diff) < (previous * 0.01)) { // Less than 1% change
    return 'neutral';
  }
  return diff > 0 ? 'up' : 'down';
}

function calculateTrendPercentage(current, previous) {
  if (previous === 0 || previous === null) {
    return 0;
  }
  return ((current - previous) / previous) * 100;
}
```

================================================================================
REQUIREMENT 7: EXAMPLE IMPLEMENTATION (Node.js/Express/MongoDB)
================================================================================

```javascript
// routes/performance.js or similar

const express = require('express');
const router = express.Router();
const Invoice = require('../models/Invoice');
const InvoiceRequest = require('../models/InvoiceRequest');
const Client = require('../models/Client');
const Employee = require('../models/Employee');
const { authenticate } = require('../middleware/auth');

// Helper function to calculate trend
function calculateTrend(current, previous) {
  if (previous === 0 || previous === null || previous === undefined) {
    return current > 0 ? 'up' : 'neutral';
  }
  const diff = current - previous;
  const percentChange = Math.abs(diff / previous);
  if (percentChange < 0.01) { // Less than 1% change
    return 'neutral';
  }
  return diff > 0 ? 'up' : 'down';
}

// Helper function to calculate trend percentage
function calculateTrendPercentage(current, previous) {
  if (previous === 0 || previous === null || previous === undefined) {
    return 0;
  }
  return ((current - previous) / previous) * 100;
}

// Helper function to get date ranges
function getDateRanges() {
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth();
  
  // Current month
  const currentMonthStart = new Date(currentYear, currentMonth, 1);
  const currentMonthEnd = new Date(currentYear, currentMonth + 1, 0, 23, 59, 59, 999);
  
  // Previous month
  const previousMonthStart = new Date(currentYear, currentMonth - 1, 1);
  const previousMonthEnd = new Date(currentYear, currentMonth, 0, 23, 59, 59, 999);
  
  return {
    current: { start: currentMonthStart, end: currentMonthEnd },
    previous: { start: previousMonthStart, end: previousMonthEnd }
  };
}

router.get('/department/Sales', authenticate, async (req, res) => {
  try {
    // Step 1: Get all Sales department employees
    const salesEmployees = await Employee.find({
      'department.name': 'Sales'
    }).select('_id employee_id');
    
    const salesEmployeeIds = salesEmployees.map(emp => emp._id || emp.employee_id);
    
    if (salesEmployeeIds.length === 0) {
      return res.json({
        success: true,
        data: {
          revenue: 0,
          revenueTrend: 'neutral',
          revenueTrendPercentage: 0,
          newLeads: 0,
          leadsTrend: 'neutral',
          leadsTrendPercentage: 0,
          conversionRate: 0,
          conversionTrend: 'neutral',
          conversionTrendPercentage: 0,
          clientSatisfaction: 0,
          satisfactionTrend: 'neutral',
          satisfactionTrendPercentage: 0
        }
      });
    }
    
    const dateRanges = getDateRanges();
    
    // Step 2: Calculate Monthly Revenue
    const currentMonthInvoices = await Invoice.aggregate([
      {
        $match: {
          created_at: { $gte: dateRanges.current.start, $lte: dateRanges.current.end },
          created_by: { $in: salesEmployeeIds },
          status: { $ne: 'CANCELLED' }
        }
      },
      {
        $group: {
          _id: null,
          total: { $sum: { $toDouble: '$total_amount' } }
        }
      }
    ]);
    
    const previousMonthInvoices = await Invoice.aggregate([
      {
        $match: {
          created_at: { $gte: dateRanges.previous.start, $lte: dateRanges.previous.end },
          created_by: { $in: salesEmployeeIds },
          status: { $ne: 'CANCELLED' }
        }
      },
      {
        $group: {
          _id: null,
          total: { $sum: { $toDouble: '$total_amount' } }
        }
      }
    ]);
    
    const revenue = currentMonthInvoices[0]?.total || 0;
    const previousRevenue = previousMonthInvoices[0]?.total || 0;
    const revenueTrend = calculateTrend(revenue, previousRevenue);
    const revenueTrendPercentage = calculateTrendPercentage(revenue, previousRevenue);
    
    // Step 3: Calculate New Leads
    const currentMonthLeads = await InvoiceRequest.countDocuments({
      created_at: { $gte: dateRanges.current.start, $lte: dateRanges.current.end },
      created_by_employee_id: { $in: salesEmployeeIds }
    });
    
    const previousMonthLeads = await InvoiceRequest.countDocuments({
      created_at: { $gte: dateRanges.previous.start, $lte: dateRanges.previous.end },
      created_by_employee_id: { $in: salesEmployeeIds }
    });
    
    const newLeads = currentMonthLeads;
    const leadsTrend = calculateTrend(currentMonthLeads, previousMonthLeads);
    const leadsTrendPercentage = calculateTrendPercentage(currentMonthLeads, previousMonthLeads);
    
    // Step 4: Calculate Conversion Rate
    const totalLeads = currentMonthLeads;
    const convertedLeads = await InvoiceRequest.countDocuments({
      created_at: { $gte: dateRanges.current.start, $lte: dateRanges.current.end },
      created_by_employee_id: { $in: salesEmployeeIds },
      status: 'COMPLETED'
    });
    
    const conversionRate = totalLeads > 0 ? (convertedLeads / totalLeads) * 100 : 0;
    
    const previousTotalLeads = previousMonthLeads;
    const previousConvertedLeads = await InvoiceRequest.countDocuments({
      created_at: { $gte: dateRanges.previous.start, $lte: dateRanges.previous.end },
      created_by_employee_id: { $in: salesEmployeeIds },
      status: 'COMPLETED'
    });
    
    const previousConversionRate = previousTotalLeads > 0 
      ? (previousConvertedLeads / previousTotalLeads) * 100 
      : 0;
    
    const conversionTrend = calculateTrend(conversionRate, previousConversionRate);
    const conversionTrendPercentage = calculateTrendPercentage(conversionRate, previousConversionRate);
    
    // Step 5: Calculate Client Satisfaction
    // Option: Calculate from repeat customers
    const totalClients = await Client.countDocuments({
      created_by: { $in: salesEmployeeIds }
    });
    
    const repeatClients = await Client.aggregate([
      {
        $match: {
          created_by: { $in: salesEmployeeIds }
        }
      },
      {
        $lookup: {
          from: 'invoices',
          localField: '_id',
          foreignField: 'client_id',
          as: 'invoices'
        }
      },
      {
        $match: {
          'invoices.0': { $exists: true },
          $expr: { $gt: [{ $size: '$invoices' }, 1] }
        }
      },
      {
        $count: 'count'
      }
    ]);
    
    const repeatCount = repeatClients[0]?.count || 0;
    const clientSatisfaction = totalClients > 0 
      ? (repeatCount / totalClients) * 100 
      : 85; // Default score
    
    // Calculate previous period satisfaction (simplified)
    const previousSatisfaction = clientSatisfaction; // Can be calculated similarly
    const satisfactionTrend = calculateTrend(clientSatisfaction, previousSatisfaction);
    const satisfactionTrendPercentage = calculateTrendPercentage(clientSatisfaction, previousSatisfaction);
    
    // Return response
    res.json({
      success: true,
      data: {
        revenue: Math.round(revenue * 100) / 100,
        revenueTrend,
        revenueTrendPercentage: Math.round(revenueTrendPercentage * 10) / 10,
        newLeads,
        leadsTrend,
        leadsTrendPercentage: Math.round(leadsTrendPercentage * 10) / 10,
        conversionRate: Math.round(conversionRate * 10) / 10,
        conversionTrend,
        conversionTrendPercentage: Math.round(conversionTrendPercentage * 10) / 10,
        clientSatisfaction: Math.round(clientSatisfaction * 10) / 10,
        satisfactionTrend,
        satisfactionTrendPercentage: Math.round(satisfactionTrendPercentage * 10) / 10
      }
    });
    
  } catch (error) {
    console.error('Error calculating Sales performance metrics:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to calculate performance metrics'
    });
  }
});

module.exports = router;
```

================================================================================
REQUIREMENT 8: DATA FIELD MAPPING
================================================================================

The backend should handle various field name variations:

INVOICE AMOUNT FIELDS:
- total_amount
- amount
- totalAmount
- invoice_amount

DATE FIELDS:
- created_at
- createdAt
- date
- created_date

EMPLOYEE ID FIELDS:
- created_by
- created_by_employee_id
- createdByEmployeeId
- createdBy

STATUS FIELDS:
- status
- invoice_status
- request_status

================================================================================
REQUIREMENT 9: PERFORMANCE CONSIDERATIONS
================================================================================

- Use database indexes on:
  * created_at / createdAt
  * created_by / created_by_employee_id
  * status
  * department (for employees)

- Consider caching the results for 30-60 seconds to reduce database load

- Use aggregation pipelines for efficient calculations

- Handle large datasets by using proper pagination or date range limits

================================================================================
REQUIREMENT 10: ERROR HANDLING
================================================================================

- Handle missing data gracefully (return 0 instead of null/undefined)
- Handle division by zero in trend calculations
- Log errors for debugging
- Return appropriate HTTP status codes:
  * 200: Success
  * 401: Unauthorized
  * 500: Server error

================================================================================
REQUIREMENT 11: TESTING CHECKLIST
================================================================================

Test Cases:
-----------
1. ✅ Endpoint returns 200 with valid data
2. ✅ All 4 metrics are present in response
3. ✅ Revenue calculation is correct
4. ✅ Leads count is accurate
5. ✅ Conversion rate is calculated correctly
6. ✅ Client satisfaction is calculated
7. ✅ Trends are calculated correctly (up/down/neutral)
8. ✅ Trend percentages are accurate
9. ✅ Handles zero values gracefully
10. ✅ Handles missing data (returns 0)
11. ✅ Authentication works correctly
12. ✅ Returns error for unauthorized access
13. ✅ Handles database errors gracefully

================================================================================
REQUIREMENT 12: ADDITIONAL NOTES
================================================================================

- The endpoint should be fast (ideally < 500ms response time)
- Consider using database views or materialized collections for better performance
- If data is large, consider calculating metrics in background jobs and caching results
- The frontend expects exact field names as specified in the response format
- All numeric values should be rounded to 1-2 decimal places
- Trend percentages can be negative (for downward trends)

================================================================================
END OF PROMPT
================================================================================

