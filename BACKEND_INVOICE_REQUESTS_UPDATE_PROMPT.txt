BACKEND PROMPT: Update Invoice Requests API for Performance Optimization

================================================================================
PRIORITY: HIGH - Performance Issue
================================================================================

ISSUE:
The `/api/invoice-requests` endpoint is taking too long to load because:
1. It's fetching ALL fields from the database (including large nested objects)
2. The frontend only needs 10-12 specific fields for the table display
3. This causes slow database queries, large JSON payloads, and slow page loads

CURRENT ENDPOINT:
GET /api/invoice-requests

REQUIRED UPDATES:
1. Add field projection support (NEW - for performance)
2. Maintain existing pagination (already implemented)
3. Maintain existing filtering (status, search)

================================================================================
UPDATE 1: ADD FIELD PROJECTION SUPPORT
================================================================================

Add support for `fields` query parameter to return only requested fields.

QUERY PARAMETER:
- `fields` (string, optional): Comma-separated list of field names
  - Example: `?fields=_id,awb,customer_name,status,createdAt`
  - If not provided, return all fields (backward compatibility)

REQUIRED FIELDS FOR TABLE DISPLAY:
The frontend requests these fields for the `/dashboard/requests` page:
1. `_id` - Request ID
2. `awb` - AWB Number (primary)
3. `awb_number` - AWB Number (alternative)
4. `tracking_code` - AWB Number (alternative)
5. `customer_name` - Customer name
6. `receiver_name` - Receiver name
7. `origin_place` - Origin location
8. `destination_place` - Destination location
9. `status` - Request status (DRAFT, SUBMITTED, IN_PROGRESS, VERIFIED, COMPLETED, CANCELLED)
10. `invoice_id` - Invoice ID (to check if invoice exists)
11. `invoice_number` - Invoice number (to check if invoice exists)
12. `verification` - Verification object (but only check existence, not full data)
13. `createdAt` - Created timestamp (or `created_at`, `created`)

IMPLEMENTATION:
```javascript
// Parse fields parameter
const fields = req.query.fields;
let projection = {};

if (fields) {
  const fieldArray = fields.split(',').map(f => f.trim());
  
  // Build projection object
  fieldArray.forEach(field => {
    projection[field] = 1; // Include this field
  });
  
  // Always include _id unless explicitly excluded
  if (!fieldArray.includes('_id') && !fieldArray.includes('-id')) {
    projection._id = 1;
  }
}

// Use projection in query
const invoiceRequests = await InvoiceRequest.find(query)
  .select(projection) // Apply field projection
  .sort({ createdAt: -1 })
  .skip(skip)
  .limit(limit)
  .lean();
```

SPECIAL HANDLING FOR VERIFICATION:
For the `verification` field, if it's requested:
- Option 1: Return minimal object: `{ exists: true }` or `{ exists: false }`
- Option 2: Use aggregation to check existence
- Option 3: Return empty object `{}` if verification doesn't exist, or minimal object if it does

Example implementation:
```javascript
if (fields && fields.includes('verification')) {
  // Use aggregation or add virtual field
  // Or post-process to return minimal verification data
  invoiceRequests = invoiceRequests.map(req => {
    if (req.verification && Object.keys(req.verification).length > 0) {
      req.verification = { exists: true }; // Minimal representation
    } else {
      req.verification = { exists: false };
    }
    return req;
  });
}
```

================================================================================
UPDATE 2: ENSURE PAGINATION WORKS WITH FIELD PROJECTION
================================================================================

The existing pagination should work seamlessly with field projection:
- Field projection should be applied AFTER building the query but BEFORE pagination
- Total count calculation should work regardless of field projection
- Pagination metadata should remain the same

================================================================================
UPDATE 3: ENSURE FILTERING WORKS WITH FIELD PROJECTION
================================================================================

Status and search filtering should work correctly with field projection:
- Filters are applied to the query (before projection)
- Projection only affects which fields are returned, not which documents match

================================================================================
EXAMPLE REQUEST:
================================================================================

GET /api/invoice-requests?page=1&limit=25&status=SUBMITTED&fields=_id,awb,customer_name,receiver_name,origin_place,destination_place,status,invoice_id,invoice_number,verification,createdAt

================================================================================
EXAMPLE RESPONSE:
================================================================================

```json
{
  "success": true,
  "data": [
    {
      "_id": "507f1f77bcf86cd799439011",
      "awb": "AESY532AKLUUZEZ3V",
      "customer_name": "ABC Company",
      "receiver_name": "John Doe",
      "origin_place": "Dubai",
      "destination_place": "Manila",
      "status": "SUBMITTED",
      "invoice_id": null,
      "invoice_number": null,
      "verification": { "exists": true },
      "createdAt": "2025-12-18T20:45:45.875Z"
    }
  ],
  "pagination": {
    "page": 1,
    "limit": 25,
    "total": 100,
    "pages": 4
  }
}
```

================================================================================
COMPLETE IMPLEMENTATION EXAMPLE:
================================================================================

```javascript
router.get('/invoice-requests', authenticate, async (req, res) => {
  try {
    // Parse query parameters
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 25, 100);
    const status = req.query.status;
    const search = req.query.search;
    const fields = req.query.fields; // NEW: Field projection
    
    // Build query object (same as before)
    const query = {};
    
    // Status filter
    if (status && status !== 'all') {
      query.status = { $regex: new RegExp(`^${status}$`, 'i') };
    }
    
    // Search filter
    if (search && search.trim()) {
      const searchRegex = new RegExp(search.trim(), 'i');
      query.$or = [
        { customer_name: searchRegex },
        { receiver_name: searchRegex },
        { awb: searchRegex },
        { tracking_code: searchRegex },
        { awb_number: searchRegex },
        { invoice_id: searchRegex },
        { invoice_number: searchRegex },
        { _id: { $regex: search.trim() } }
      ];
    }
    
    // Calculate pagination
    const skip = (page - 1) * limit;
    
    // Get total count (before pagination and projection)
    const total = await InvoiceRequest.countDocuments(query);
    
    // Build projection object (NEW)
    let projection = {};
    if (fields) {
      const fieldArray = fields.split(',').map(f => f.trim());
      fieldArray.forEach(field => {
        projection[field] = 1;
      });
      // Always include _id
      if (!fieldArray.includes('_id')) {
        projection._id = 1;
      }
    }
    
    // Fetch paginated data with projection
    let invoiceRequests = await InvoiceRequest.find(query)
      .select(Object.keys(projection).length > 0 ? projection : undefined)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean();
    
    // Handle verification field specially (if requested)
    if (fields && fields.includes('verification')) {
      invoiceRequests = invoiceRequests.map(req => {
        if (req.verification && Object.keys(req.verification).length > 0) {
          req.verification = { exists: true };
        } else {
          req.verification = { exists: false };
        }
        return req;
      });
    }
    
    // Calculate total pages
    const pages = Math.ceil(total / limit);
    
    return res.json({
      success: true,
      data: invoiceRequests,
      pagination: {
        page,
        limit,
        total,
        pages
      }
    });
  } catch (error) {
    console.error('Error fetching invoice requests:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to fetch invoice requests'
    });
  }
});
```

================================================================================
PERFORMANCE BENEFITS:
================================================================================

1. **Reduced Data Transfer**: 
   - Before: Full document (50+ fields, nested objects) = ~5-10KB per record
   - After: Minimal fields (10-12 fields) = ~500 bytes per record
   - **90% reduction in payload size**

2. **Faster Database Queries**:
   - MongoDB only fetches requested fields
   - Less data to serialize/deserialize
   - Faster network transfer

3. **Faster Frontend Rendering**:
   - Less data to process
   - Faster JSON parsing
   - Faster React rendering

4. **Estimated Performance Improvement**:
   - Current: 2-5 seconds for 25 records
   - Expected: 200-500ms for 25 records
   - **10x faster loading time**

================================================================================
BACKWARD COMPATIBILITY:
================================================================================

- If `fields` parameter is NOT provided, return ALL fields (current behavior)
- Existing frontend code will continue to work
- New frontend code will request minimal fields for better performance

================================================================================
TESTING REQUIREMENTS:
================================================================================

1. Test with `fields` parameter:
   - Request with specific fields
   - Verify only requested fields are returned
   - Verify _id is always included

2. Test without `fields` parameter:
   - Verify all fields are returned (backward compatibility)
   - Verify existing functionality still works

3. Test with pagination:
   - Verify pagination works with field projection
   - Verify total count is accurate

4. Test with filters:
   - Verify status filter works with field projection
   - Verify search filter works with field projection

5. Test verification field:
   - Verify verification existence check works correctly
   - Verify minimal verification object is returned

6. Performance test:
   - Compare response times with and without field projection
   - Verify significant performance improvement

================================================================================
NOTES:
================================================================================

- Field projection should work with populated fields if any
- Ensure indexes are still used effectively with field projection
- Consider adding indexes on frequently requested fields
- The frontend will send the `fields` parameter automatically once backend supports it
- This is a non-breaking change (backward compatible)

================================================================================
PRIORITY: Implement this ASAP to improve page load performance
================================================================================

