# Backend Implementation: Booking Filters with Query Parameters

## Overview
The frontend now sends filter parameters (`status` and `awb`) as query parameters to the backend. The backend must filter the **full database** (not just paginated results) before returning data. This ensures no data is missed when filtering.

## Endpoints to Update

### 1. GET /api/bookings

**Purpose**: Get all bookings with optional filters.

**Request**:
- Method: `GET`
- Headers: 
  - `Authorization: Bearer <token>` (if authentication required)
  - `Content-Type: application/json`
- URL: `/api/bookings`
- Query Parameters:
  - `status` (string, optional) - Filter by review status (e.g., "not reviewed", "reviewed", "rejected")
  - `awb` (string, optional) - Filter by AWB number (partial match, case-insensitive)

**Example Requests**:
```
GET /api/bookings
GET /api/bookings?status=not reviewed
GET /api/bookings?awb=ABC123
GET /api/bookings?status=not reviewed&awb=ABC123
```

**Response** (200 OK):
```json
{
  "success": true,
  "data": [
    {
      "_id": "booking_id_1",
      "tracking_code": "ABC123",
      "awb_number": "ABC123",
      "review_status": "not reviewed",
      "customer_name": "John Doe",
      // ... other booking fields
    },
    // ... more bookings
  ]
}
```

**Implementation Logic**:
1. **Build Query**: Start with base query (all bookings)
2. **Apply Status Filter**: If `status` query parameter exists, filter by `review_status`
3. **Apply AWB Filter**: If `awb` query parameter exists, search in:
   - `tracking_code`
   - `awb_number`
   - `request_id.tracking_code`
   - `request_id.awb_number`
   - Use case-insensitive partial match (contains)
4. **Execute Query**: Query the **full database** (no pagination limit at this stage)
5. **Return Results**: Return filtered array

**MongoDB/Mongoose Example**:
```javascript
// Express.js route handler
router.get('/bookings', authenticateToken, async (req, res) => {
  try {
    const { status, awb } = req.query;
    
    // Build query object
    const query = {};
    
    // Apply status filter
    if (status) {
      // Normalize status values
      const normalizedStatus = status.toLowerCase().trim();
      
      // Handle various status formats
      if (normalizedStatus === 'not reviewed' || 
          normalizedStatus === 'not_reviewed' || 
          normalizedStatus === 'pending' ||
          normalizedStatus === 'notreviewed') {
        // Match null, undefined, empty string, or "not reviewed" variants
        query.$or = [
          { review_status: { $exists: false } },
          { review_status: null },
          { review_status: '' },
          { review_status: { $in: ['not reviewed', 'not_reviewed', 'pending', 'notreviewed', 'Not Reviewed'] } }
        ];
      } else if (normalizedStatus === 'reviewed' || normalizedStatus === 'approved') {
        query.review_status = { $in: ['reviewed', 'approved', 'Reviewed', 'Approved'] };
      } else if (normalizedStatus === 'rejected') {
        query.review_status = { $in: ['rejected', 'Rejected'] };
      } else {
        // Exact match for other statuses
        query.review_status = { $regex: new RegExp(`^${normalizedStatus}$`, 'i') };
      }
    }
    
    // Apply AWB filter (case-insensitive partial match)
    if (awb && awb.trim()) {
      const awbSearch = awb.trim();
      query.$and = query.$and || [];
      query.$and.push({
        $or: [
          { tracking_code: { $regex: awbSearch, $options: 'i' } },
          { awb_number: { $regex: awbSearch, $options: 'i' } },
          { 'request_id.tracking_code': { $regex: awbSearch, $options: 'i' } },
          { 'request_id.awb_number': { $regex: awbSearch, $options: 'i' } }
        ]
      });
    }
    
    // Execute query on FULL database (no limit/pagination here)
    const bookings = await Booking.find(query)
      .sort({ createdAt: -1 }) // Most recent first
      .lean(); // Use lean() for better performance
    
    return res.json({
      success: true,
      data: bookings
    });
  } catch (error) {
    console.error('Error fetching bookings:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});
```

---

### 2. GET /api/bookings/status/:status

**Purpose**: Get bookings filtered by review status with optional AWB filter.

**Request**:
- Method: `GET`
- Headers: 
  - `Authorization: Bearer <token>` (if authentication required)
  - `Content-Type: application/json`
- URL: `/api/bookings/status/:status`
- URL Parameters:
  - `status` (string, required) - Review status (e.g., "not reviewed", "reviewed", "rejected")
- Query Parameters:
  - `awb` (string, optional) - Filter by AWB number (partial match, case-insensitive)

**Example Requests**:
```
GET /api/bookings/status/not reviewed
GET /api/bookings/status/not reviewed?awb=ABC123
GET /api/bookings/status/reviewed?awb=XYZ
```

**Response** (200 OK):
```json
{
  "success": true,
  "data": [
    {
      "_id": "booking_id_1",
      "tracking_code": "ABC123",
      "review_status": "not reviewed",
      // ... other booking fields
    },
    // ... more bookings matching status and AWB
  ]
}
```

**Implementation Logic**:
1. **Extract Status**: Get status from URL parameter
2. **Normalize Status**: Handle various status formats (same as above)
3. **Build Query**: Start with status filter
4. **Apply AWB Filter**: If `awb` query parameter exists, add AWB search conditions
5. **Execute Query**: Query the **full database** (no pagination limit)
6. **Return Results**: Return filtered array

**MongoDB/Mongoose Example**:
```javascript
// Express.js route handler
router.get('/bookings/status/:status', authenticateToken, async (req, res) => {
  try {
    const { status } = req.params; // From URL parameter
    const { awb } = req.query; // From query string
    
    // Build query object
    const query = {};
    
    // Normalize and apply status filter
    const normalizedStatus = status.toLowerCase().trim();
    
    if (normalizedStatus === 'not reviewed' || 
        normalizedStatus === 'not_reviewed' || 
        normalizedStatus === 'pending' ||
        normalizedStatus === 'notreviewed') {
      query.$or = [
        { review_status: { $exists: false } },
        { review_status: null },
        { review_status: '' },
        { review_status: { $in: ['not reviewed', 'not_reviewed', 'pending', 'notreviewed', 'Not Reviewed'] } }
      ];
    } else if (normalizedStatus === 'reviewed' || normalizedStatus === 'approved') {
      query.review_status = { $in: ['reviewed', 'approved', 'Reviewed', 'Approved'] };
    } else if (normalizedStatus === 'rejected') {
      query.review_status = { $in: ['rejected', 'Rejected'] };
    } else {
      query.review_status = { $regex: new RegExp(`^${normalizedStatus}$`, 'i') };
    }
    
    // Apply AWB filter if provided
    if (awb && awb.trim()) {
      const awbSearch = awb.trim();
      query.$and = query.$and || [];
      query.$and.push({
        $or: [
          { tracking_code: { $regex: awbSearch, $options: 'i' } },
          { awb_number: { $regex: awbSearch, $options: 'i' } },
          { 'request_id.tracking_code': { $regex: awbSearch, $options: 'i' } },
          { 'request_id.awb_number': { $regex: awbSearch, $options: 'i' } }
        ]
      });
    }
    
    // Execute query on FULL database (no limit/pagination)
    const bookings = await Booking.find(query)
      .sort({ createdAt: -1 })
      .lean();
    
    return res.json({
      success: true,
      data: bookings
    });
  } catch (error) {
    console.error('Error fetching bookings by status:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});
```

---

## Important Requirements

### 1. Filter Full Database
- **CRITICAL**: Apply filters to the **entire database**, not just paginated results
- Do NOT apply pagination limits before filtering
- Filter first, then return all matching results
- Frontend handles pagination if needed

### 2. Status Normalization
Handle these status variations:
- `"not reviewed"`, `"not_reviewed"`, `"pending"`, `"notreviewed"` → Match null/empty/undefined or these values
- `"reviewed"`, `"approved"` → Match these values
- `"rejected"` → Match this value
- Case-insensitive matching

### 3. AWB Search
Search in these fields (case-insensitive, partial match):
- `tracking_code`
- `awb_number`
- `request_id.tracking_code` (if request_id is populated)
- `request_id.awb_number` (if request_id is populated)

### 4. Performance Considerations
- **Indexes**: Ensure indexes on:
  - `review_status`
  - `tracking_code`
  - `awb_number`
  - `request_id.tracking_code`
  - `request_id.awb_number`
- **Lean Queries**: Use `.lean()` for better performance (returns plain objects)
- **Sorting**: Sort by `createdAt: -1` (most recent first)

### 5. Error Handling
- Return 500 error for database/server errors
- Return 200 with empty array if no results found
- Validate query parameters (trim whitespace, handle null/undefined)

---

## Database Indexes

Create these indexes for optimal performance:

```javascript
// In your Mongoose schema or migration script
db.bookings.createIndex({ review_status: 1 });
db.bookings.createIndex({ tracking_code: 1 });
db.bookings.createIndex({ awb_number: 1 });
db.bookings.createIndex({ "request_id.tracking_code": 1 });
db.bookings.createIndex({ "request_id.awb_number": 1 });

// Compound index for common queries
db.bookings.createIndex({ review_status: 1, tracking_code: 1 });
```

---

## Testing Checklist

- [ ] `GET /api/bookings` returns all bookings
- [ ] `GET /api/bookings?status=not reviewed` filters by status correctly
- [ ] `GET /api/bookings?awb=ABC123` filters by AWB correctly
- [ ] `GET /api/bookings?status=not reviewed&awb=ABC123` filters by both
- [ ] `GET /api/bookings/status/not reviewed` returns correct status
- [ ] `GET /api/bookings/status/not reviewed?awb=ABC123` filters by both
- [ ] Status normalization works for all variations ("not reviewed", "not_reviewed", "pending", etc.)
- [ ] AWB search is case-insensitive
- [ ] AWB search works with partial matches
- [ ] AWB search checks all relevant fields (tracking_code, awb_number, request_id fields)
- [ ] Returns empty array when no matches found
- [ ] Handles null/undefined status values correctly
- [ ] Performance is acceptable (< 1 second for typical queries)
- [ ] Indexes are in place and working

---

## Example Query Scenarios

### Scenario 1: Get all "not reviewed" bookings
```
GET /api/bookings?status=not reviewed
```
**Backend Query**:
```javascript
Booking.find({
  $or: [
    { review_status: { $exists: false } },
    { review_status: null },
    { review_status: '' },
    { review_status: { $in: ['not reviewed', 'not_reviewed', 'pending'] } }
  ]
})
```

### Scenario 2: Search AWB "ABC123" in all bookings
```
GET /api/bookings?awb=ABC123
```
**Backend Query**:
```javascript
Booking.find({
  $or: [
    { tracking_code: { $regex: 'ABC123', $options: 'i' } },
    { awb_number: { $regex: 'ABC123', $options: 'i' } },
    { 'request_id.tracking_code': { $regex: 'ABC123', $options: 'i' } },
    { 'request_id.awb_number': { $regex: 'ABC123', $options: 'i' } }
  ]
})
```

### Scenario 3: Get "not reviewed" bookings with AWB containing "ABC"
```
GET /api/bookings?status=not reviewed&awb=ABC
```
**Backend Query**:
```javascript
Booking.find({
  $and: [
    {
      $or: [
        { review_status: { $exists: false } },
        { review_status: null },
        { review_status: '' },
        { review_status: { $in: ['not reviewed', 'not_reviewed', 'pending'] } }
      ]
    },
    {
      $or: [
        { tracking_code: { $regex: 'ABC', $options: 'i' } },
        { awb_number: { $regex: 'ABC', $options: 'i' } },
        { 'request_id.tracking_code': { $regex: 'ABC', $options: 'i' } },
        { 'request_id.awb_number': { $regex: 'ABC', $options: 'i' } }
      ]
    }
  ]
})
```

---

## Notes

1. **No Pagination**: The frontend expects all filtered results. Do NOT apply pagination limits in these endpoints.

2. **URL Encoding**: Handle URL-encoded status values (e.g., "not%20reviewed" = "not reviewed")

3. **Empty Results**: Return empty array `[]` if no bookings match the filters, not an error.

4. **Consistency**: Both endpoints (`/api/bookings` and `/api/bookings/status/:status`) should use the same filtering logic for consistency.

5. **Performance**: If the database is very large, consider:
   - Adding database indexes (critical)
   - Using aggregation pipeline for complex queries
   - Caching frequently accessed filter combinations

6. **Security**: Validate and sanitize query parameters to prevent NoSQL injection attacks.

---

## Security: NoSQL Injection Prevention

Always sanitize query parameters:

```javascript
// Sanitize status parameter
const sanitizeStatus = (status) => {
  if (!status || typeof status !== 'string') return null;
  return status.trim().replace(/[^a-zA-Z0-9_\s-]/g, '');
};

// Sanitize AWB parameter
const sanitizeAwb = (awb) => {
  if (!awb || typeof awb !== 'string') return null;
  return awb.trim().replace(/[^a-zA-Z0-9]/g, '');
};

// Use in route handlers
const cleanStatus = sanitizeStatus(req.query.status);
const cleanAwb = sanitizeAwb(req.query.awb);
```

---

## Quick Implementation Template

```javascript
// routes/bookings.js
const express = require('express');
const router = express.Router();
const Booking = require('../models/Booking');

// Helper: Normalize status
function normalizeStatus(status) {
  if (!status) return null;
  const normalized = status.toLowerCase().trim();
  
  if (['not reviewed', 'not_reviewed', 'pending', 'notreviewed'].includes(normalized)) {
    return 'not_reviewed';
  }
  if (['reviewed', 'approved'].includes(normalized)) {
    return 'reviewed';
  }
  if (normalized === 'rejected') {
    return 'rejected';
  }
  return normalized;
}

// Helper: Build status query
function buildStatusQuery(status) {
  const normalized = normalizeStatus(status);
  
  if (normalized === 'not_reviewed') {
    return {
      $or: [
        { review_status: { $exists: false } },
        { review_status: null },
        { review_status: '' },
        { review_status: { $in: ['not reviewed', 'not_reviewed', 'pending', 'notreviewed', 'Not Reviewed'] } }
      ]
    };
  }
  
  if (normalized === 'reviewed') {
    return { review_status: { $in: ['reviewed', 'approved', 'Reviewed', 'Approved'] } };
  }
  
  if (normalized === 'rejected') {
    return { review_status: { $in: ['rejected', 'Rejected'] } };
  }
  
  return { review_status: { $regex: new RegExp(`^${normalized}$`, 'i') } };
}

// Helper: Build AWB query
function buildAwbQuery(awb) {
  if (!awb || !awb.trim()) return null;
  
  const awbSearch = awb.trim();
  return {
    $or: [
      { tracking_code: { $regex: awbSearch, $options: 'i' } },
      { awb_number: { $regex: awbSearch, $options: 'i' } },
      { 'request_id.tracking_code': { $regex: awbSearch, $options: 'i' } },
      { 'request_id.awb_number': { $regex: awbSearch, $options: 'i' } }
    ]
  };
}

// GET /api/bookings
router.get('/bookings', authenticateToken, async (req, res) => {
  try {
    const { status, awb } = req.query;
    const query = {};
    
    // Apply status filter
    if (status) {
      Object.assign(query, buildStatusQuery(status));
    }
    
    // Apply AWB filter
    if (awb) {
      const awbQuery = buildAwbQuery(awb);
      if (awbQuery) {
        if (Object.keys(query).length > 0) {
          query.$and = [{ ...query }, awbQuery];
          delete query.$or; // Remove $or if it exists, it's now in $and
        } else {
          Object.assign(query, awbQuery);
        }
      }
    }
    
    // Execute query on FULL database
    const bookings = await Booking.find(query)
      .sort({ createdAt: -1 })
      .lean();
    
    return res.json({
      success: true,
      data: bookings
    });
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// GET /api/bookings/status/:status
router.get('/bookings/status/:status', authenticateToken, async (req, res) => {
  try {
    const { status } = req.params;
    const { awb } = req.query;
    const query = {};
    
    // Apply status filter from URL parameter
    Object.assign(query, buildStatusQuery(status));
    
    // Apply AWB filter from query string
    if (awb) {
      const awbQuery = buildAwbQuery(awb);
      if (awbQuery) {
        query.$and = [{ ...query }, awbQuery];
      }
    }
    
    // Execute query on FULL database
    const bookings = await Booking.find(query)
      .sort({ createdAt: -1 })
      .lean();
    
    return res.json({
      success: true,
      data: bookings
    });
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

module.exports = router;
```

---

## Summary

- Accept `status` and `awb` as query parameters
- Filter the **full database** (not paginated results)
- Handle status normalization (various formats)
- Search AWB in multiple fields (case-insensitive, partial match)
- Return all matching results (no pagination limit)
- Use indexes for performance
- Sanitize inputs to prevent NoSQL injection

